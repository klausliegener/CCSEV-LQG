(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ClearAll["Global`*"];(*Clear all previous cache of mathematica*)
timestamp1=SessionTime[];(*Remember local time: start of programme*)


SetDirectory[NotebookDirectory[]]; 
(*This version does not open the plaquette anymore*)Get["DiracQV2.m"];
$Assumptions={t>0,Const>0,\[Eta]>0,\[Xi]>0};
ParallelEvaluate[$Assumptions={t>0,Const>0,\[Eta]>0,\[Xi]>0};];


(*Here we add our operators, and set few useful things: eE is the unit vector which will shift the vertex in a link-dependent way. L is the range of links; \[CapitalOmega] is an auxiliary operator without physical meaning. Const is the constant denoted by capital epsilon. IMPORTANT:Ignore the sentences "Please enter all neccessary basic commutation and anticommutation relations. For help type ?AddOperator". do not define commutators.*) 
AddOperator[\[CapitalEpsilon]];
AddOperator[h];
AddOperator[Q];
AddOperator[V];
AddOperator[\[CapitalOmega]];
eE[\[Mu]_]:={If[Abs[\[Mu]]==1,Sign[\[Mu]],0],If[Abs[\[Mu]]==2,Sign[\[Mu]],0],If[Abs[\[Mu]]==3,Sign[\[Mu]],0]};
L:={-3,-2,-1,1,2,3};
L0=1;
eps[i_,j_,k_]:=LeviCivitaTensor[3][[i,j,k]];

(*We also set replacement rules as follows - they are consistent with [arXiv: 2012.07813]!:*)
(*Classical replacements:*)
(*[h,h]-Classical: commutator[h[\[Mu]x_,vx1_,vx2_,vx3_,ax_,bx_,J1_],h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J2_]]\[Rule]0*)
(*[Q,Q]-Classical: commutator[Q[vx1_,vx2_,vx3_,Nx_],Q[vy1_,vy2_,vy3_,Ny_]]\[Rule]0*)
(*[E,E]-Classical: commutator[\[CapitalEpsilon][px,\[Mu]x_,vx1_,vx2_,vx3_,kx_],\[CapitalEpsilon][py,\[Mu]y_,vy1_,vy2_,vy3_,ky_]]\[Rule]*)RepC1[px_,py_,\[Mu]x_,vx1_,vx2_,vx3_,kx_,\[Mu]y_,vy1_,vy2_,vy3_,ky_]:=Module[{kz},AppendTo[RVar, kz];-Const \[Delta][vx1,vy1]\[Delta][vx2,vy2]\[Delta][vx3,vy3](\[Delta][\[Mu]x,\[Mu]y]+py \[Delta][\[Mu]x,-\[Mu]y])S[kz]ff[kx,ky,kz]\[CapitalEpsilon][px py,\[Mu]x,vx1,vx2,vx3,kz]];
(*[E,h]-Classical: commutator[\[CapitalEpsilon][px,\[Mu]x_,vx1_,vx2_,vx3_,kx_],h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]]\[Rule]*)RepC2[px_,\[Mu]x_,vx1_,vx2_,vx3_,kx_,\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]:= Module[{cz,dz},T[Const (\[Delta][vx1,vy1]\[Delta][vx2,vy2]\[Delta][vx3,vy3](\[Delta][\[Mu]x,\[Mu]y]+px \[Delta][\[Mu]x,-\[Mu]y])S[{cz,-J,J}]S[{dz,-J,J}]\[Tau]n[Abs[\[Mu]y],kx,ay,cz,J]\[Delta][by,dz] -    \[Delta][vx1,vy1+eE[\[Mu]y][[1]]]\[Delta][vx2,vy2+eE[\[Mu]y][[2]]]\[Delta][vx3,vy3+eE[\[Mu]y][[3]]](px \[Delta][\[Mu]x,\[Mu]y]+\[Delta][\[Mu]x,-\[Mu]y])S[{cz,-J,J}]S[{dz,-J,J}]\[Tau]n[Abs[\[Mu]y],kx,dz,by,J]\[Delta][ay,cz])]h[\[Mu]y,vy1,vy2,vy3,cz,dz,J]];
(*[Q,h]-Classical: commutator[Q[vx1_,vx2_,vx3_,Nx_],h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]]\[Rule]*)RepC3[vx1_,vx2_,vx3_,Nx_,\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]:=Module[{i,j,k,cz,dz},AppendTo[RVar,{i,j,k}];T[6Const I TT[Nx] Sign[\[Mu]y]S[i,j,k]EpsilonN[i,j,k,Mod[Abs[\[Mu]y]+1,3,1],Mod[Abs[\[Mu]y]+2,3,1],Abs[\[Mu]y]](\[Delta][vx1,vy1]\[Delta][vx2,vy2]\[Delta][vx3,vy3]S[{cz,-J,J}]S[{dz,-J,J}]\[Tau]n[Abs[\[Mu]y],k,ay,cz,J]\[Delta][by,dz]+\[Delta][vx1,vy1+eE[\[Mu]y][[1]]]\[Delta][vx2,vy2+eE[\[Mu]y][[2]]]\[Delta][vx3,vy3+eE[\[Mu]y][[3]]]S[{cz,-J,J}]S[{dz,-J,J}]\[Delta][ay,cz]\[Tau]n[Abs[\[Mu]y],k,dz,by,J])]h[\[Mu]y,vy1,vy2,vy3,cz,dz,J]**\[CapitalEpsilon][-1,Mod[Abs[\[Mu]y]+1,3,1],vx1,vx2,vx3,i]**\[CapitalEpsilon][-1,Mod[Abs[\[Mu]y]+2,3,1],vx1,vx2,vx3,j]**Q[vx1,vx2,vx3,Nx-1]];
(*[Q,E]-Classical: commutator[Q[vx1_,vx2_,vx3_,Nx_],\[CapitalEpsilon][py,\[Mu]y_,vy1_,vy2_,vy3_,ky_]]\[Rule]*)RepC4[py_,vx1_,vx2_,vx3_,Nx_,\[Mu]y_,vy1_,vy2_,vy3_,ky_]:=Module[{i,j,k,kz},AppendTo[RVar,{i,j,k,kz}];-6Const TT[Nx]  I \[Delta][vx1,vy1]\[Delta][vx2,vy2]\[Delta][vx3,vy3]S[i,j,k,kz]EpsilonN[i,j,k,Mod[Abs[\[Mu]y]+1,3,1],Mod[Abs[\[Mu]y]+2,3,1],Abs[\[Mu]y]]ff[ky,k,kz]**\[CapitalEpsilon][-1,Mod[Abs[\[Mu]y]+1,3,1],vx1,vx2,vx3,i]**\[CapitalEpsilon][-1,Mod[Abs[\[Mu]y]+2,3,1],vx1,vx2,vx3,j]**\[CapitalEpsilon][-py,\[Mu]y,vx1,vx2,vx3,kz]**Q[vx1,vx2,vx3,Nx-1]];
(*Classical replacements:*)
(*\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Upsilon]\)]\(\([\)\(h, h\)\(]\)\)\)-Quantum: commutator[h[\[Mu]x_,vx1_,vx2_,vx3_,ax_,bx_,J1_],h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J2_]]\[Rule]0*)
(*\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Upsilon]\)]\(\([\)\(Q, Q\)\(]\)\)\)-Quantum: commutator[Q[vx1_,vx2_,vx3_,Nx_],Q[vy1_,vy2_,vy3_,Ny_]]\[Rule]0*)
(*\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Upsilon]\)]\(\([\)\(E, E\)\(]\)\)\)-Quantum: commutator[\[CapitalEpsilon][\[Mu]x_,vx1_,vx2_,vx3_,kx_],\[CapitalEpsilon][\[Mu]y_,vy1_,vy2_,vy3_,ky_]]\[Rule]0*)
(*\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Upsilon]\)]\(\([\)\(E, h\)\(]\)\)\)-Quantum: commutator[\[CapitalEpsilon][\[Mu]x_,vx1_,vx2_,vx3_,kx_],h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]]\[Rule]0*)
(*\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Upsilon]\)]\(\([\)\(Q, h\)\(]\)\)\)-Quantum: commutator[Q[vx1_,vx2_,vx3_,Nx_],h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]]\[Rule]RepQ3[vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ay,by,J]*)RepQ3[vx1_,vx2_,vx3_,Nx_,\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]:=Module[{i,j,k,cz,dz},AppendTo[RVar,{i,j,k}];-3Const I TT[Nx (Nx-1)]Sign[\[Mu]y]S[i,j,k]EpsilonN[i,j,k,Mod[Abs[\[Mu]y]+1,3,1],Mod[Abs[\[Mu]y]+2,3,1],Abs[\[Mu]y]] T[(\[Delta][vx1,vy1]\[Delta][vx2,vy2]\[Delta][vx3,vy3]S[{cz,-J,J}]S[{dz,-J,J}]\[Tau]n[Abs[\[Mu]y],k,ay,cz,J]\[Delta][by,dz]+\[Delta][vx1,vy1+eE[\[Mu]y][[1]]]\[Delta][vx2,vy2+eE[\[Mu]y][[2]]]\[Delta][vx3,vy3+eE[\[Mu]y][[3]]]S[{cz,-J,J}]S[{dz,-J,J}]\[Delta][ay,cz]\[Tau]n[Abs[\[Mu]y],k,dz,by,J])]Commutator[h[\[Mu]y,vy1,vy2,vy3,cz,dz,J]**\[CapitalEpsilon][-1,Mod[Abs[\[Mu]y]+1,3,1],vx1,vx2,vx3,i]**\[CapitalEpsilon][-1,Mod[Abs[\[Mu]y]+2,3,1],vx1,vx2,vx3,j],Q[vx1,vx2,vx3,1]]**Q[vx1,vx2,vx3,Nx-2]];
(*\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Upsilon]\)]\(\([\)\(Q, E\)\(]\)\)\)-Quantum: ccommutator[Q[vx1_,vx2_,vx3_,Nx_],\[CapitalEpsilon][py,\[Mu]y_,vy1_,vy2_,vy3_,ky_]]\[Rule]RepQ4[py,vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ky]*)RepQ4[py_,vx1_,vx2_,vx3_,Nx_,\[Mu]y_,vy1_,vy2_,vy3_,ky_]:=Module[{i,j,k,kz},AppendTo[RVar,{i,j,k,kz}];-3Const I TT[Nx (Nx-1)]\[Delta][vx1,vy1]\[Delta][vx2,vy2]\[Delta][vx3,vy3]S[kz,i,j,k]EpsilonN[i,j,k,Mod[Abs[\[Mu]y]+1,3,1],Mod[Abs[\[Mu]y]+2,3,1],Abs[\[Mu]y]]ff[ky,k,kz]Commutator[\[CapitalEpsilon][-1,Mod[Abs[\[Mu]y]+1,3,1],vx1,vx2,vx3,i]**\[CapitalEpsilon][-1,Mod[Abs[\[Mu]y]+2,3,1],vx1,vx2,vx3,j]**\[CapitalEpsilon][-py,\[Mu]y,vx1,vx2,vx3,kz],Q[vx1,vx2,vx3,1]]**Q[vx1,vx2,vx3,Nx-2]];
(*EpsilonN and ff shall have a clear meaning. The objects S serve to store the new summation indices appearing during the computation. THe objects T[] and TT[] are to be thought of as intermediary brackets whose expansion shall be avoided when using the mathematica command "Expand[]". Note that HoloVar and RVar are lists supposed to store information about types of these extra indices. Uniqueness of the new indices is assured by the "Module".*)

(*DeltResolver will simplify expressions where many indices are equal, via implementing the appearing \[Delta] functions*)
DeltResolver[AA_]:=Module[{deltList,interA,count},count=1;interA=AA;While[count=!=0,count=0;deltList={};interA=interA/.{\[Delta][a_,b_]:> (AppendTo[deltList,{S[{b,-1/2,1/2}]-> 1,b->a}];1)/;count++==0};If[Length[deltList]>0,Do[interA=interA/.deltList[[i]],{i,1,Length[deltList]}]]];interA];


DistributeDefinitions["DiracQ`"];
Print["Using ",$KernelCount," parallel kernels"];
Print["Initializing..."];


HEucl[v_,a1_,a2_,a3_,a4_,a5_,a6_,{d1_,d2_,d3_}]:=(h[d1,v,a6,a1,1/2]**h[d2,v+eE[d1],a1,a2,1/2]**h[-d1,v+eE[d1]+eE[d2],a2,a3,1/2]**h[-d2,v+eE[d2],a3,a4,1/2]**h[d3,v,a4,a5,1/2]-h[d2,v,a6,a1,1/2]**h[d1,v+eE[d2],a1,a2,1/2]**h[-d2,v+eE[d1]+eE[d2],a2,a3,1/2]**h[-d1,v+eE[d1],a3,a4,1/2]**h[d3,v,a4,a5,1/2])**Commutator[h[-d3,v+eE[d3],a5,a6,1/2],(V[v]+V[v+eE[d3]])]/t;
EH[v_,a1_,a2_,a3_,a4_,a5_,a6_]:=Sum[Sign[d3]s1 s2 HEucl[v,a1,a2,a3,a4,a5,a6,{s1 Mod[Abs[d3]+1,3,1],s2 Mod[Abs[d3]+2,3,1],d3}],{d3,L},{s1,{-1,1}},{s2,{-1,1}}];

HEuclCompact[v_,a1_,a2_,a3_,a4_,a5_,b1_,b2_,b3_,{d1_,d2_,d3_}]:=1/t loopcoefficent[a5,a1,b3,b1] h[d1,v,a1,a2,1/2]**h[d2,v+eE[d1],a2,a3,1/2]**h[-d1,v+eE[d1]+eE[d2],a3,a4,1/2]**h[-d2,v+eE[d2],a4,a5,1/2]**h[d3,v,b1,b2,1/2]**Commutator[h[-d3,v+eE[d3],b2,b3,1/2],(V[v]+V[v+eE[d3]])];
HEuclCompactDag[v_,a1_,a2_,a3_,a4_,a5_,b1_,b2_,b3_,{d1_,d2_,d3_}]:=1/t loopcoefficent[a5,a1,b3,b1]Commutator[h[-d3,v+eE[d3],b2,b3,1/2],(V[v]+V[v+eE[d3]])]**h[d3,v,b1,b2,1/2]**h[-d2,v+eE[d2],a4,a5,1/2]**h[-d1,v+eE[d1]+eE[d2],a3,a4,1/2]**h[d2,v+eE[d1],a2,a3,1/2]** h[d1,v,a1,a2,1/2];(*derivation follows from h^+f(g)=Overscript[D(g),_] f(g)*)


(*V*)(*
Title="Vol";
$RecursionLimit=16390;
Oper=V[{v1,v2,v3}]**\[CapitalOmega][];
M=4;
Jmax=2;
MVolAppr=3;
IndicesIni0={};
VertList={{v1,{0}},{v2,{0}},{v3,{0}}};
*)


(*H*)(*
Title="CE";
$RecursionLimit=16390;
Oper=pEuc Sum[Sign[d3]s1 s2(HEuclCompact[{0,0,0},a1,a2,a3,a4,a5,aa1,aa2,aa3,{s1 Mod[Abs[d3]+1,3,1],s2 Mod[Abs[d3]+2,3,1],d3}]),{d3,L}]**\[CapitalOmega][];
M=4;
Jmax=2;
MVolAppr=3;
IndicesIni0={{a1,-1/2,1/2},{a2,-1/2,1/2},{a3,-1/2,1/2},{a4,-1/2,1/2},{a5,-1/2,1/2},{aa1,-1/2,1/2},{aa2,-1/2,1/2},{aa3,-1/2,1/2}};
VertList={{s1,{-1,1}},{s2,{-1,1}}};
*)


(*H+H^+*)(*
Title="CEcc";
$RecursionLimit=16390;
Oper=pEuc Sum[(Sign[d3]s1 s2)/2(HEuclCompact[{0,0,0},a1,a2,a3,a4,a5,aa1,aa2,aa3,{s1 Mod[Abs[d3]+1,3,1],s2 Mod[Abs[d3]+2,3,1],d3}]+HEuclCompactDag[{0,0,0},a1,a2,a3,a4,a5,aa1,aa2,aa3,{s1 Mod[Abs[d3]+1,3,1],s2 Mod[Abs[d3]+2,3,1],d3}]),{d3,L}]**\[CapitalOmega][];
M=4;
Jmax=2;
MVolAppr=3;
IndicesIni0={{a1,-1/2,1/2},{a2,-1/2,1/2},{a3,-1/2,1/2},{a4,-1/2,1/2},{a5,-1/2,1/2},{aa1,-1/2,1/2},{aa2,-1/2,1/2},{aa3,-1/2,1/2}};
VertList={{s1,{-1,1}},{s2,{-1,1}}};
*)


(*[H+H^+,v]*)(*
Title="Vdot";
$RecursionLimit=16390;
d3=3;
Oper=6(*due to fixed d3*) pEuc (I \[Kappa])/(t l^2)(Sign[d3]s1 s2)/2Commutator[(HEuclCompact[{0,0,0},a1,a2,a3,a4,a5,aa1,aa2,aa3,{s1 Mod[Abs[d3]+1,3,1],s2 Mod[Abs[d3]+2,3,1],d3}]+HEuclCompactDag[{0,0,0},a1,a2,a3,a4,a5,aa1,aa2,aa3,{s1 Mod[Abs[d3]+1,3,1],s2 Mod[Abs[d3]+2,3,1],d3}]),V[{v1,v2,v3}]]**\[CapitalOmega][];
M=4;
Jmax=2;
MVolAppr=3;
IndicesIni0={{a1,-1/2,1/2},{a2,-1/2,1/2},{a3,-1/2,1/2},{a4,-1/2,1/2},{a5,-1/2,1/2},{aa1,-1/2,1/2},{aa2,-1/2,1/2},{aa3,-1/2,1/2}};
VertList={{s1,{-1,1}},{s2,{-1,1}},{v1,-1,1},{v2,-1,1},{v3,-1,1}};
*)


(*[H+H^+,V]V*)(*
Title="VdotV";
$RecursionLimit=16390;
d3=3;
Oper=6(*due to fixed d3*)pEuc (I \[Kappa])/(t l^2)(Sign[d3]s1 s2)/2Commutator[(HEuclCompact[{0,0,0},a1,a2,a3,a4,a5,aa1,aa2,aa3,{s1 Mod[Abs[d3]+1,3,1],s2 Mod[Abs[d3]+2,3,1],d3}]+HEuclCompactDag[{0,0,0},a1,a2,a3,a4,a5,aa1,aa2,aa3,{s1 Mod[Abs[d3]+1,3,1],s2 Mod[Abs[d3]+2,3,1],d3}]),V[{v1,v2,v3}]]**V[{v4,v5,v6}]**\[CapitalOmega][];
M=4;
Jmax=2;
MVolAppr=3;(*ATTENTION: should be 3*)
IndicesIni0={{a1,-1/2,1/2},{a2,-1/2,1/2},{a3,-1/2,1/2},{a4,-1/2,1/2},{a5,-1/2,1/2},{aa1,-1/2,1/2},{aa2,-1/2,1/2},{aa3,-1/2,1/2}};
VertList={{s1,{-1,1}},{s2,{-1,1}},{v1,-1,1},{v2,-1,1},{v3,-1,1}};
Oper=Plus@@Flatten[Oper/.{{v4\[Rule]0,v5\[Rule]0,v6\[Rule]0},{v4\[Rule]s1,v5\[Rule]0,v6\[Rule] 0},{v4\[Rule]s1,v5\[Rule]s2,v6\[Rule] 0},{v4\[Rule]0,v5\[Rule]s2,v6\[Rule] 0},{v4\[Rule]0,v5\[Rule]0,v6\[Rule] 1}}];
*)

(*V[H^+,V]*)(*
Title="VVdot";
$RecursionLimit=16390;
d3=3;
Oper=6(*due to fixed d3*)pEuc (I \[Kappa])/(t l^2)(Sign[d3]s1 s2)/2V[{v4,v5,v6}]**Commutator[(HEuclCompact[{0,0,0},a1,a2,a3,a4,a5,aa1,aa2,aa3,{s1 Mod[Abs[d3]+1,3,1],s2 Mod[Abs[d3]+2,3,1],d3}]+HEuclCompactDag[{0,0,0},a1,a2,a3,a4,a5,aa1,aa2,aa3,{s1 Mod[Abs[d3]+1,3,1],s2 Mod[Abs[d3]+2,3,1],d3}]),V[{v1,v2,v3}]]**\[CapitalOmega][];
M=4;
Jmax=2;
MVolAppr=3;
IndicesIni0={{a1,-1/2,1/2},{a2,-1/2,1/2},{a3,-1/2,1/2},{a4,-1/2,1/2},{a5,-1/2,1/2},{aa1,-1/2,1/2},{aa2,-1/2,1/2},{aa3,-1/2,1/2}};
VertList={{s1,{-1,1}},{s2,{-1,1}},{v1,-1,1},{v2,-1,1},{v3,-1,1}};
Oper=Plus@@Flatten[Oper/.{{v4\[Rule]0,v5\[Rule]0,v6\[Rule]0},{v4\[Rule]s1,v5\[Rule]0,v6\[Rule] 0},{v4\[Rule]s1,v5\[Rule]s2,v6\[Rule] 0},{v4\[Rule]0,v5\[Rule]s2,v6\[Rule] 0},{v4\[Rule]0,v5\[Rule]0,v6\[Rule] 1}}];
*)


(*Here we define the operator of interest.*)


Title="CE";
$RecursionLimit=16390;
Oper=pEuc Sum[Sign[d3]s1 s2(HEuclCompact[{0,0,0},a1,a2,a3,a4,a5,aa1,aa2,aa3,{s1 Mod[Abs[d3]+1,3,1],s2 Mod[Abs[d3]+2,3,1],d3}]),{d3,L}]**\[CapitalOmega][];
M=4;
Jmax=2;
MVolAppr=3;
IndicesIni0={{a1,-1/2,1/2},{a2,-1/2,1/2},{a3,-1/2,1/2},{a4,-1/2,1/2},{a5,-1/2,1/2},{aa1,-1/2,1/2},{aa2,-1/2,1/2},{aa3,-1/2,1/2}};
VertList={{s1,{-1,1}},{s2,{-1,1}}};


(*We start with removing "{}".*)
Oper=Oper/.{h[\[Mu]_,{v1_,v2_,v3_},a_,b_,J_]->h[\[Mu],v1,v2,v3,a,b,J],Q[{v1_,v2_,v3_},Nx_]->Q[v1,v2,v3,Nx],V[{v1_,v2_,v3_}]->tinv^(3/2) t^(3/2)V[v1,v2,v3]};

(*Below we replace the operator by a vector of monomials. Lop is the length of this vector.*)
OperOrg=Organize[Oper];Lop=Length[OperOrg];Oper=Table[Humanize[{OperOrg[[j]]}],{j,1,Lop}];Clear[OperOrg];Oper=Select[Oper/.{commutator[h[\[Mu]x_,vx1_,vx2_,vx3_,ax_,bx_,J1_],h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J2_]]->0,commutator[Q[vx1_,vx2_,vx3_,Nx_],Q[vy1_,vy2_,vy3_,Ny_]]->0},Not[#===0]&];
Lop=Length[Oper];
(*We need to bring back the default value of the $RecursionLimit.*)
$RecursionLimit=1024;
(*We now need to collect indices appearing inside Oper, together with their summation ranges.*)



(*We need to fix the maximal "spin" J to appear during the computation.*)
Jset=Table[j/2,{j,0,2Jmax}];

(*Finally, we compute quantities used as final replacements*)
Quiet[
(*The needed coefficients for the highest volume operator approximation*)VolAppList=CoefficientList[1+Sum[(-1)^n/n! Product[i-1/4,{i,0,n-1}] Sum[(-1)^(n-i) Binomial[n,i] q^(2 i),{i,0,n}],{n,1,2 MVolAppr+1}],q];Do[cV[n]=pV q0^(1/2) VolAppList[[n+1]]/q0^n,{n,0,2 (2 MVolAppr+1)}];(*Other symbols:*)
Do[Do[\[Tau]Aux[k,a,b,J]=I Sqrt[J(J+1)(2J+1)](-1)^(J+b) ThreeJSymbol[{J,b},{1,k},{J,-a}],{k,-1,1},{a,-J,J},{b,-J,J}],{J,Jset}];
Do[Do[\[Tau]nAux[\[Mu]y,k,a,b,J]=Sum[DWig[a,a1,\[Mu]y,J]\[Tau]Aux[k,a1,b1,J]Conjugate[DWig[b,b1,\[Mu]y,J]],{a1,-J,J},{b1,-J,J}],{k,-1,1},{a,-J,J},{b,-J,J},{\[Mu]y,1,3}],{J,Jset}];
(*Structure function for su(2) algebra. (II.5)*)Do[ffAux[k1,k2,k3]=-I If[(k1==0&&k2==1&&k3==1)||(k1==-1&&k2==0&&k3==-1)||(k1==-1&&k2==1&&k3==0),1,If[(k1==1&&k2==0&&k3==1)||(k1==0&&k2==-1&&k3==-1)||(k1==1&&k2==-1&&k3==0),-1,0]],{k1,-1,1},{k2,-1,1},{k3,-1,1}];
(*Rotation matrices (II.13)*)Do[Do[DWig[a,a1,\[Mu]y,J]=If[\[Mu]y==1,WignerD[{J,a,a1},0,-Pi/2,0],0]+
If[\[Mu]y==2,WignerD[{J,a,a1},-Pi/2,-Pi/2,Pi/2],0]+If[\[Mu]y==3,WignerD[{J,a,a1},0,0,0],0],{a,-J,J},{a1,-J,J},{\[Mu]y,1,3}],{J,Jset}];
WM[1,a_,b_]:=WignerD[{1,a,b},0,-Pi/2,0];
WM[2,a_,b_]:=WignerD[{1,a,b},-Pi/2,-Pi/2,Pi/2];
WM[3,a_,b_]:=WignerD[{1,a,b},0,0,0];Do[EpsilonNAux[a,b,c,m1,m2,m3]=Sum[I Sqrt[6] ThreeJSymbol[{1,i},{1,j},{1,k}] WM[m1,-i,-a] WM[m2,-j,-b] WM[m3,-k,-c],{i,-1,1},{j,-1,1},{k,-1,1}],{a,-1,1},{b,-1,1},{c,-1,1},{m1,1,3},{m2,1,3},{m3,1,3}];
(*Expectation value on one edge (II.22)*)
Do[Do[X1Aux[a,a1,\[Mu]y,J]=If[\[Mu]y==1,WignerD[{J,a,a1},Pi/2,\[Xi],-Pi/2],0]+
If[\[Mu]y==2,WignerD[{J,a,a1},Pi,-\[Xi],-Pi],0]+If[\[Mu]y==3,WignerD[{J,a,a1},\[Xi]/2,0,\[Xi]/2],0],{a,-J,J},{a1,-J,J},{\[Mu]y,1,3}],{J,Jset}];
Do[Do[X2Aux[ay1,by1,\[Mu]y,J]= Sum[DWig[ay1,a1,\[Mu]y,J]Conjugate[DWig[by1,a1,\[Mu]y,J]]Exp[I \[Xi] a1]((a1^2-J^2-J)Tanh[\[Eta]/2]/(2\[Eta])-a1^2/4),{a1,-J,J}],{ay1,-J,J},{by1,-J,J},{\[Mu]y,1,3}],{J,Jset}];
Do[Do[Y1Aux[ay1,by1,m,J]=1/2/\[Eta] Sum[DWig[ay1,a1,m,J]Conjugate[DWig[by1,a1,m,J]] a1 Exp[I \[Xi] a1],{a1,-J,J}],{ay1,-J,J},{by1,-J,J},{m,1,3}],{J,Jset}];
Do[Do[Y2Aux[ay1,by1,m,J,kz]=  I/2/\[Eta](\[Delta][kz,-1]+\[Delta][kz,1]+\[Delta][kz,0] )(1- kz Tanh[\[Eta]/2])
Sum[DWig[ay1,a1,m,J]Conjugate[DWig[by1,b1,m,J]]\[Tau]Aux[kz,a1,b1,J]Exp[I \[Xi] b1],{a1,-J,J},{b1,-J,J}],{ay1,-J,J},{by1,-J,J},{kz,-1,1},{m,1,3}],{J,Jset}];
Do[Y3Aux[ky,kz]=-1/2/\[Eta]/Sinh[\[Eta]](\[Delta][ky,1]\[Delta][kz,-1]+\[Delta][ky,-1]\[Delta][kz,1])Exp[ky \[Eta]],{ky,-1,1},{kz,-1,1}];
(*SU(2) recouplign coefficients (IV.18b)*)
Do[Do[ZAuxP[1,J1,J2,J,a,c,m]=(2J+1)(-1)^(m)ThreeJSymbol[{J1,a},{J2,c},{J,m}],{a,-Jmax,Jmax,1/2},{c,-Jmax,Jmax,1/2},{m,-Jmax,Jmax,1/2}],{J,Jset},{J1,Jset},{J2,Jset}];
Do[Do[ZAuxP[2,J1,J2,J,b,d,n]=(-1)^(-n)ThreeJSymbol[{J1,b},{J2,d},{J,n}],{b,-Jmax,Jmax,1/2},{d,-Jmax,Jmax,1/2},{n,-Jmax,Jmax,1/2}],{J,Jset},{J1,Jset},{J2,Jset}];
(*Additional coefficient to make the computation of the Euclidian scalar constraint computationally less expensive*)
Do[loopcoefficentAux[a5,a1,b3,b1]=Sum[Sum[ZAuxP[1,1/2,1/2,J,b3,b1,M]ZAuxP[2,1/2,1/2,J,a1,a5,M]-(-1)^(a1-a5)ZAuxP[1,1/2,1/2,J,b3,b1,M]ZAuxP[2,1/2,1/2,J,a1,a5,-M],{M,-J,J}],{J,0,1}],{a5,-1/2,1/2},{a1,-1/2,1/2},{b3,-1/2,1/2},{b1,-1/2,1/2}];
]


Resultc=Table[0,{i,1,Lop}];
Resultq=Table[0,{i,1,Lop}];
SetSharedVariable[Resultc];SetSharedVariable[Resultq];

IntVol=Table[0,{i,1,Lop}];IntRVar=Table[0,{i,1,Lop}];
SetSharedVariable[IntVol];SetSharedVariable[IntRVar];
TestOper=0;TestDiff=Table[1,{i,1,Lop}];VolVar={};AAA=Oper;count=1;
While[Not[count==0],
Module[{Nx},AppendTo[VolVar,Nx];
Do[count=0;
AAA[[lll]]=AAA[[lll]]/.{V[v1_,v2_,v3_]:>cV[Nx]*Q[v1,v2,v3,Nx]/; count++==0}
,{lll,1,Lop}]
]];
Oper2=AAA;

SetSharedVariable[LoopCounting];
LoopCounting=0;
timestamp2=SessionTime[];
Print["CommutatorFlatten: ",Lop];
ParallelDo[
(*We first delete operators which are added in each loop, clear all explicit symbols and empty the lists of extra indices.*)
DeleteOperator[R];DeleteOperator[Lr];
DeleteOperator[Dh];DeleteOperator[DhD];
Clear[\[Tau]n,ff,Z,X1,X2,Y1,Y2,Y3,EpsilonN,\[Gamma],gv];
RVar={};
(*We define Pcl and Pqu*)
Pcl=SimplifyQ[Oper2[[iii]]/.commutator->Commutator];
Pqu=0;
(*We make STEP I - presimplification. The While loop lets it work till there are no more commutators*)
count=1;
(*First While loop replaces commutators in Pcl (using classical replacements) and adds terms to Pqu - using quantum replacements*)
While[count=!=0,count=0;
Pcl=Pcl//.{a_**1->a,a_**0->0,0**a_->0};
AAA=Pcl/.{commutator[h[\[Mu]x_,vx1_,vx2_,vx3_,ax_,bx_,J1_],h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J2_]]->0,commutator[Q[vx1_,vx2_,vx3_,Nx_],Q[vy1_,vy2_,vy3_,Ny_]]->0};
AAA=AAA/.{commutator[\[CapitalEpsilon][px_,\[Mu]x_,vx1_,vx2_,vx3_,kx_],\[CapitalEpsilon][py_,\[Mu]y_,vy1_,vy2_,vy3_,ky_]]:>RepC1[px,py,\[Mu]x,vx1,vx2,vx3,kx,\[Mu]y,vy1,vy2,vy3,ky] /; count++>= 0};
AAA=AAA/.{commutator[\[CapitalEpsilon][px_,\[Mu]x_,vx1_,vx2_,vx3_,kx_],h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]]:>RepC2[px,\[Mu]x,vx1,vx2,vx3,kx,\[Mu]y,vy1,vy2,vy3,ay,by,J]/;count++>=0};
AAA=AAA/.{commutator[h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_],\[CapitalEpsilon][px_,\[Mu]x_,vx1_,vx2_,vx3_,kx_]]:>-RepC2[px,\[Mu]x,vx1,vx2,vx3,kx,\[Mu]y,vy1,vy2,vy3,ay,by,J]/;count++>=0};
AAA=AAA/.{commutator[Q[vx1_,vx2_,vx3_,Nx_],h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]]:>(RepC3[vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ay,by,J]+ttt RepQ3[vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ay,by,J])/;count++>=0};
AAA=AAA/.{commutator[h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_],Q[vx1_,vx2_,vx3_,Nx_]]:>-(RepC3[vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ay,by,J]+ttt RepQ3[vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ay,by,J])/;count++>= 0};
AAA=AAA/.{commutator[Q[vx1_,vx2_,vx3_,Nx_],\[CapitalEpsilon][py_,\[Mu]y_,vy1_,vy2_,vy3_,ky_]]:>(RepC4[py,vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ky]+ttt RepQ4[py,vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ky])/;count++>=0};
AAA=AAA/.{commutator[\[CapitalEpsilon][py_,\[Mu]y_,vy1_,vy2_,vy3_,ky_],Q[vx1_,vx2_,vx3_,Nx_]]:>-(RepC4[py,vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ky]+ttt RepQ4[py,vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ky])/; count++>=0};
AAA=AAA/.{T[0]-> 0}/.commutator->Commutator;
Pcl=AAA/.ttt->0;
Pqu=Pqu+D[AAA,ttt]/.ttt->0;];
Pcl=Pcl//.{a_**1-> a,a_**0-> 0,0**a_-> 0};
Pcl=SimplifyQ[Pcl];
Pqu=Pqu//.{a_**1-> a,a_**0-> 0,0**a_-> 0};
Pqu=SimplifyQ[Pqu];
count=1;
(*Second While loop replaces commutators in Pqu - using classical replacements*)
If[Not[Pqu===0],While[count=!=0,
AAA=Pqu;count=0;
AAA=AAA//.{commutator[h[\[Mu]x_,vx1_,vx2_,vx3_,ax_,bx_,J1_],h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J2_]]->0,commutator[Q[vx1_,vx2_,vx3_,Nx_],Q[vy1_,vy2_,vy3_,Ny_]]->0};
AAA=AAA//.{commutator[\[CapitalEpsilon][px_,\[Mu]x_,vx1_,vx2_,vx3_,kx_],\[CapitalEpsilon][py_,\[Mu]y_,vy1_,vy2_,vy3_,ky_]]:>RepC1[px,py,\[Mu]x,vx1,vx2,vx3,kx,\[Mu]y,vy1,vy2,vy3,ky] /; count++>= 0};
AAA=AAA//.{commutator[\[CapitalEpsilon][px_,\[Mu]x_,vx1_,vx2_,vx3_,kx_],h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]]:>RepC2[px,\[Mu]x,vx1,vx2,vx3,kx,\[Mu]y,vy1,vy2,vy3,ay,by,J]/; count++>= 0};
AAA=AAA//.{commutator[h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_],\[CapitalEpsilon][px_,\[Mu]x_,vx1_,vx2_,vx3_,kx_]]:>-RepC2[px,\[Mu]x,vx1,vx2,vx3,kx,\[Mu]y,vy1,vy2,vy3,ay,by,J]/; count++>= 0};
AAA=AAA//.{commutator[Q[vx1_,vx2_,vx3_,Nx_],h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]]:>RepC3[vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ay,by,J]/; count++>= 0};
AAA=AAA//.{commutator[h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_],Q[vx1_,vx2_,vx3_,Nx_]]:>-RepC3[vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ay,by,J]/; count++>=  0};
AAA=AAA//.{commutator[Q[vx1_,vx2_,vx3_,Nx_],\[CapitalEpsilon][py_,\[Mu]y_,vy1_,vy2_,vy3_,ky_]]:>RepC4[py,vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ky]/; count++>= 0};
AAA=AAA//.{commutator[\[CapitalEpsilon][py_,\[Mu]y_,vy1_,vy2_,vy3_,ky_],Q[vx1_,vx2_,vx3_,Nx_]]:>-RepC4[py,vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ky]/;  count++>= 0};
Pqu=AAA/.commutator->Commutator];Pqu=Pqu/.Q[vx1_,vx2_,vx3_,0]->1;
];
(*We make STEP II. The While loop lets it work till the desired order is obtained*)
count=1;
(*First While loop does the order in Pcl (moves h to the left) and adds terms to Pqu - using classical replacements. We also freely move Q to the right (also right to \[CapitalOmega][]).*)
While[count=!=0,count=0;
AAA=Pcl//.{
\[CapitalEpsilon][px_,\[Mu]x_,vx1_,vx2_,vx3_,kx_]**h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]:> h[\[Mu]y,vy1,vy2,vy3,ay,by,J]**\[CapitalEpsilon][px,\[Mu]x,vx1,vx2,vx3,kx]+ttt RepC2[px,\[Mu]x,vx1,vx2,vx3,kx,\[Mu]y,vy1,vy2,vy3,ay,by,J]/; count++>= 0};
AAA=AAA//.{
Q[vx1_,vx2_,vx3_,Nx_]**h[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]:>  h[\[Mu]y,vy1,vy2,vy3,ay,by,J]**Q[vx1,vx2,vx3,Nx]+ttt  RepC3[vx1,vx2,vx3,Nx,\[Mu]y,vy1,vy2,vy3,ay,by,J]/; count++>= 0};
AAA=AAA//.{
Q[vx1_,vx2_,vx3_,Nx_]**\[CapitalEpsilon][py_,\[Mu]y_,vy1_,vy2_,vy3_,ky_]:> \[CapitalEpsilon][py,\[Mu]y,vy1,vy2,vy3,ky]**Q[vx1,vx2,vx3,Nx]/; count++>= 0};AAA=AAA//.{Q[vx1_,vx2_,vx3_,Nx_]**\[CapitalOmega][]:>  \[CapitalOmega][]**Q[vx1,vx2,vx3,Nx]/; count++>= 0};
Pcl=AAA/.ttt->0;
Pqu=Pqu+ D[AAA,ttt]/.ttt->0;
];
IntRVar[[iii]]=RVar;
Resultc[[iii]]=SimplifyQ[Pcl/.{T[x_]-> x}];Resultq[[iii]]=Pqu/.{T[x_]-> x};
LoopCounting=LoopCounting+1;
,{iii,1,Lop}];
Print["CommutatorFlatten: Time ",Round[SessionTime[]-timestamp2,0.01]];
Oper2=Select[Transpose[{Transpose[{Resultc,Resultq}],Transpose[{IntVol,IntRVar}]}],Not[#[[1]]==={0,0}]&];
Clear[AAA,Oper,IntRVar];
(*vvvvvvvvvvvvvvv*)
(*If the computation turns out to be to heavy, a way to split it into two parts and to extract an intermediary result is to uncomment the following line. It can be loaded via the following block*)
(*Export["ExpValue_Intermediate.txt",Verbatim[Oper2]];*)
(*^^^^^^^^^^^^^^^*)
If[Not[VertList==={}],Oper2=Flatten[Table[Oper2,Sequence@@VertList//Evaluate],Length[VertList]]];
timestamp2=SessionTime[];
Print["DeltaResolver:",Length[Oper2]];
Do[
If[Head[Oper2[[i,1,1]]]===Plus,Do[Oper2[[i,1,1,j]]=DeltResolver[Oper2[[i,1,1,j]]],{j,1,Length[Oper2[[i,1,1]]]}],Oper2[[i,1,1]]=DeltResolver[Oper2[[i,1,1]]]];If[Head[Oper2[[i,1,2]]]===Plus,Do[Oper2[[i,1,2,j]]=DeltResolver[Oper2[[i,1,2,j]]],{j,1,Length[Oper2[[i,1,2]]]}],Oper2[[i,1,2]]=DeltResolver[Oper2[[i,1,2]]]],{i,1,Length[Oper2]}];
Oper2=Select[Oper2,Not[#[[1]]==={0,0}]&];
Lop=Length[Oper2];
Print["DeltaResolver: Time ",Round[SessionTime[]-timestamp2,0.01]]


(*vvvvvvvvvvvvvvv*)
(*This only when ExpValue_Intermediate.txt is supposed to be loaded*)
(*Oper2=ToExpression[Import["ExpValue_Intermediate.txt"]][[1]];
If[Not[VertList==={}],Oper2=Flatten[Table[Oper2,Sequence@@VertList//Evaluate],Length[VertList]]];
Do[If[Head[Oper2[[i,1,1]]]===Plus,Do[Oper2[[i,1,1,j]]=DeltResolver[Oper2[[i,1,1,j]]],{j,1,Length[Oper2[[i,1,1]]]}],Oper2[[i,1,1]]=DeltResolver[Oper2[[i,1,1]]]];If[Head[Oper2[[i,1,2]]]===Plus,Do[Oper2[[i,1,2,j]]=DeltResolver[Oper2[[i,1,2,j]]],{j,1,Length[Oper2[[i,1,2]]]}],Oper2[[i,1,2]]=DeltResolver[Oper2[[i,1,2]]]],{i,1,Length[Oper2]}];
Oper2=Select[Oper2,Not[#[[1]]==={0,0}]&];
Lop=Length[Oper2];*)
(*^^^^^^^^^^^^^^^*)


timestamp2=SessionTime[];
Print["Splitting long monomials: ",Lop];
Do[If [Length[Oper2[[ll]][[1,1]]]>20,kk=Ceiling[Length[Oper2[[ll]][[1,1]]]/20];
Do[neulisteC[k]=Oper2[[ll]][[1,1]][[1+k Floor[Length[Oper2[[ll]][[1,1]]]/kk];;(k+1) Floor[Length[Oper2[[ll]][[1,1]]]/kk]]],{k,0,kk-2}];
neulisteC[kk-1]=Oper2[[ll]][[1,1]][[(kk-1) Floor[Length[Oper2[[ll]][[1,1]]]/kk]+1;;Length[Oper2[[ll]][[1,1]]]]];Do[neulisteQ[k]=Oper2[[ll]][[1,2]][[1+k Floor[Length[Oper2[[ll]][[1,2]]]/kk];;(k+1) Floor[Length[Oper2[[ll]][[1,2]]]/kk]]],{k,0,kk-2}];neulisteQ[kk-1]=Oper2[[ll]][[1,2]][[(kk-1) Floor[Length[Oper2[[ll]][[1,2]]]/kk]+1;;Length[Oper2[[ll]][[1,2]]]]];
Do[AppendTo[Oper2, {{neulisteC[k],neulisteQ[k]},{0,Oper2[[ll]][[2,2]]}}],{k,0,kk-1}];Oper2[[ll]]={{0,0},{0,0}}];
,{ll,1,Lop}];
Print["Splitting long monomials: Time ",Round[SessionTime[]-timestamp2,0.01]];Lop=Length[Oper2]


(*We will proceed in the Do "loop", going through the vector of monomials. This will be done in parallelized way!*)


LoopCounting=0;timestamp2=SessionTime[];
Print["Evaluating Expectation Values: ",Lop];
Resultc=Table[ResC[i],{i,1,Lop}];
Resultq=Table[ResQ[i],{i,1,Lop}];
SetSharedVariable[Resultc];SetSharedVariable[Resultq];
AbsoluteTiming[ParallelDo[
DeleteOperator[R];DeleteOperator[Lr];
DeleteOperator[Dh];DeleteOperator[DhD];
Clear[\[Tau]n,ff,Z,X1,X2,Y1,Y2,Y3,EpsilonN,\[Gamma],gv];
IndicesIni=IndicesIni0;
Pcl=Oper2[[iii,1,1]];Pqu=Oper2[[iii,1,2]];
RVar=Oper2[[iii,2,2]];
VolLength=Length[VolVar];
tt1=SessionTime[];
(*We add the operators Dh and DhD - daggered Dh - and replace the holonomies.*)
AddOperator[Dh];AddOperator[DhD];
Pcl=Pcl/.{
h[1,vy1_,vy2_,vy3_,ay_,by_,J_]->Dh[1,vy1,vy2,vy3,ay,by,J],h[2,vy1_,vy2_,vy3_,ay_,by_,J_]->Dh[2,vy1,vy2,vy3,ay,by,J],h[3,vy1_,vy2_,vy3_,ay_,by_,J_]->Dh[3,vy1,vy2,vy3,ay,by,J],
h[-1,vy1_,vy2_,vy3_,ay_,by_,J_]->DhD[1,vy1-1,vy2,vy3,ay,by,J],h[-2,vy1_,vy2_,vy3_,ay_,by_,J_]->DhD[2,vy1,vy2-1,vy3,ay,by,J],h[-3,vy1_,vy2_,vy3_,ay_,by_,J_]->DhD[3,vy1,vy2,vy3-1,ay,by,J]
};
Pqu=Pqu/.{
h[1,vy1_,vy2_,vy3_,ay_,by_,J_]->Dh[1,vy1,vy2,vy3,ay,by,J],h[2,vy1_,vy2_,vy3_,ay_,by_,J_]->Dh[2,vy1,vy2,vy3,ay,by,J],h[3,vy1_,vy2_,vy3_,ay_,by_,J_]->Dh[3,vy1,vy2,vy3,ay,by,J],h[-1,vy1_,vy2_,vy3_,ay_,by_,J_]->DhD[1,vy1-1,vy2,vy3,ay,by,J],h[-2,vy1_,vy2_,vy3_,ay_,by_,J_]->DhD[2,vy1,vy2-1,vy3,ay,by,J],h[-3,vy1_,vy2_,vy3_,ay_,by_,J_]->DhD[3,vy1,vy2,vy3-1,ay,by,J]
};
(*We make STEP III. First of all we get rid of E in Pqu.*)
Pqu=SimplifyQ[Pqu/.{\[CapitalEpsilon][1,\[Mu]x_,vx1_,vx2_,vx3_,kx_]->0,\[CapitalEpsilon][-1,\[Mu]x_,vx1_,vx2_,vx3_,kx_]->2I \[Eta]/t Const delt[kx],\[CapitalOmega][]->1}];
(*Now we add R and L as operators. The latter one is denoted by Lr.*)
AddOperator[R];AddOperator[Lr];
(*We replace E by R and L inside Pcl*)
Pcl=SimplifyQ[Pcl/.{\[CapitalEpsilon][1,1,vx1_,vx2_,vx3_,kx_]->Const*(R[1,vx1,vx2,vx3,kx]-Lr[1,vx1-1,vx2,vx3,kx]),\[CapitalEpsilon][1,2,vx1_,vx2_,vx3_,kx_]->Const*(R[2,vx1,vx2,vx3,kx]-Lr[2,vx1,vx2-1,vx3,kx]),\[CapitalEpsilon][1,3,vx1_,vx2_,vx3_,kx_]->Const*(R[3,vx1,vx2,vx3,kx]-Lr[3,vx1,vx2,vx3-1,kx]),\[CapitalEpsilon][-1,1,vx1_,vx2_,vx3_,kx_]->Const*(R[1,vx1,vx2,vx3,kx]+Lr[1,vx1-1,vx2,vx3,kx]),\[CapitalEpsilon][-1,2,vx1_,vx2_,vx3_,kx_]->Const*(R[2,vx1,vx2,vx3,kx]+Lr[2,vx1,vx2-1,vx3,kx]),\[CapitalEpsilon][-1,3,vx1_,vx2_,vx3_,kx_]->Const*(R[3,vx1,vx2,vx3,kx]+Lr[3,vx1,vx2,vx3-1,kx])}];

(*We work with Lr using the while loop. We shift Lr abelian to the right*)
TestDiff=0;
Pcl=Pcl//.{Lr[\[Mu]x_,vx1_,vx2_,vx3_,kx_]**R[\[Mu]y_,vy1_,vy2_,vy3_,ky_]->R[\[Mu]y,vy1,vy2,vy3,ky]**Lr[\[Mu]x,vx1,vx2,vx3,kx],Lr[\[Mu]x_,vx1_,vx2_,vx3_,kx_]**\[CapitalOmega][]-> R[\[Mu]x,vx1,vx2,vx3,kx]**\[CapitalOmega][]**(Exp[I z(*(\[Xi]-I \[Eta])*) kx])};
Pcl=Pcl/.\[CapitalOmega][]->1;
(*Pcl=Pcl/.{R[\[Mu]y_,vy1_,vy2_,vy3_,ky_]\[Rule]R[\[Mu]y,Mod[vy1,M],Mod[vy2,M],Mod[vy3,M],ky]};*)
(*STEP IV*)
(*Next we set the lattice.*)
Pcl=SimplifyQ[Pcl/.{Q[vx1_,vx2_,vx3_,Nx_]->Q[Mod[vx1,M],Mod[vx2,M],Mod[vx3,M],Nx],R[\[Mu]y_,vy1_,vy2_,vy3_,ky_]->R[\[Mu]y,Mod[vy1,M],Mod[vy2,M],Mod[vy3,M],ky],Dh[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]->Dh[\[Mu]y,Mod[vy1,M],Mod[vy2,M],Mod[vy3,M],ay,by,J],DhD[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]->DhD[\[Mu]y,Mod[vy1,M],Mod[vy2,M],Mod[vy3,M],ay,by,J]}];
Pqu=SimplifyQ[Pqu/.{Q[vx1_,vx2_,vx3_,Nx_]->Q[Mod[vx1,M],Mod[vx2,M],Mod[vx3,M],Nx],Dh[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]->Dh[\[Mu]y,Mod[vy1,M],Mod[vy2,M],Mod[vy3,M],ay,by,J],DhD[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]->DhD[\[Mu]y,Mod[vy1,M],Mod[vy2,M],Mod[vy3,M],ay,by,J]}];
(*Now we can get rid of products of holonomies, and afterwards properly replace DhD by Dh.*)
(*We also replace DHD by Dh. The parameter \[Gamma] is introcuced in order to avoid bugs in the package.It should be set to -1 at some point*)
Pcl=Pcl/.{DhD[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]->(\[Gamma])^(by-ay)Dh[\[Mu]y,vy1,vy2,vy3,-by,-ay,J]};
Pqu=Pqu/.{DhD[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]->(\[Gamma])^(by-ay)Dh[\[Mu]y,vy1,vy2,vy3,-by,-ay,J]};
tt15=SessionTime[];
(*We transform Pcl and Pqu into lists of monomials PclHum and PquHum. These lists have lengths Lcl and Lqu. We also extract abelian (C) and non-abelian (Q) parts.*)
If[Head[Pcl]===Plus,PclHum=List@@Pcl;Lcl=Length[PclHum];
PclHumQ=Table[TakeQPart[PclHum[[j]]],{j,1,Lcl}];
PclHumC=Table[TakeCPart[PclHum[[j]]],{j,1,Lcl}],PclHum=Pcl;Lcl=1;
PclHumQ={TakeQPart[PclHum]};PclHumC={TakeCPart[PclHum]}];
If[Head[Pqu]===Plus,PquHum=List@@Pqu;Lqu=Length[PquHum];
PquHumC=Table[TakeCPart[PquHum[[j]]],{j,1,Lqu}];
PquHumQ=Table[TakeQPart[PquHum[[j]]],{j,1,Lqu}],PquHum=Pqu;Lqu=1;
PquHumC={TakeCPart[PquHum]};
PquHumQ={TakeQPart[PquHum]}];
PclHumQ=PclHumQ/.{0}->0;
PquHumQ=PquHumQ/.{0}->0;
(*We do some job with dummy indices*)
RVar=Flatten[RVar];
RepInd=Table[RVar[[qq]]->{RVar[[qq]],-1,1},{qq,1,Length[RVar]}];
(*We create objects "GGG" being the result of link splitting. We do that only for the operator part of the monomial.*)
tt2=SessionTime[];
(*Here we do this for the classical case.*)
GGGcl=SimplifyQ[Table[PclHumQ[[lll,1]]/.{Dh[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]->If[\[Mu]y==m&&vy1==i1&&vy2==i2&&vy3==i3,Dh[\[Mu]y,vy1,vy2,vy3,ay,by,J],1],R[\[Mu]y_,vy1_,vy2_,vy3_,ky_]->If[\[Mu]y==m&&vy1==i1&&vy2==i2&&vy3==i3,R[\[Mu]y,vy1,vy2,vy3,ky],1],Q[vy1_,vy2_,vy3_,Nx_]->If[vy1==i1&&vy2==i2&&vy3==i3,Q[vy1,vy2,vy3,Nx],1]},{lll,1,Lcl},{m,1,3},{i1,0,M-1},{i2,0,M-1},{i3,0,M-1}]];
(*Here we collect powers of Q in each vertex/link. It is only done for the classical part.*)
GGGcl=GGGcl//.{1**a_->a,a_**1->a}//.{
Q[vx1_,vx2_,vx3_,N1_]**Q[vx1_,vx2_,vx3_,N2_]->Q[vx1,vx2,vx3,N1+N2]};
(*Here we build the factor (Qfactor) coming from the Q's. In GGGvol we collect the powers of Q. Afterwards, GGGcl does not contain Q anymore.*)
GGGvol=GGGcl/.{R[\[Mu]y_,vy1_,vy2_,vy3_,ky_]->1,Dh[\[Mu]y_,vy1_,vy2_,vy3_,ay1_,by1_,J_]->1};
GGGvol=GGGvol//.{a_**b_->a b};
GGGvol=Log[GGGvol]/.-\[Infinity]->0;
GGGvol=GGGvol/.{Log[Q[vy1_,vy2_,vy3_,Nx_]]->Nx};
Qfactor=Table[Product[(-Const*gv \[Eta]/t)^(GGGvol[[lll,m,i1,i2,i3]]),{m,1,3},{i1,1,M},{i2,1,M},{i3,1,M}],{lll,1,Lcl}];
GGGcl=GGGcl/.{
Q[vx1_,vx2_,vx3_,N1_]->1};
GGGcl=GGGcl//.{a_**1->a};
(*Here - in GGGNE we collect the powers of E. Further we collect sets of their indices*)
GGGNE=GGGcl/.{Dh[\[Mu]y_,vy1_,vy2_,vy3_,ay1_,by1_,J_]->1,R[\[Mu]y_,vy1_,vy2_,vy3_,ky_]->Ne};
GGGNE=GGGNE//.{a_**b_->a b};
GGGNE=Log[GGGNE]/.-\[Infinity]->0;
GGGNE=GGGNE/.{Ne->E};
Off[General::normal];GGGEindices=(GGGcl//.{Dh[\[Mu]y_,vy1_,vy2_,vy3_,ay1_,by1_,J_]->1,R[\[Mu]y_,vy1_,vy2_,vy3_,ky_]**R[\[Mu]y_,vy1_,vy2_,vy3_,kz_]->R[\[Mu]y,vy1,vy2,vy3,{ky,kz}]})/.R[\[Mu]y_,vy1_,vy2_,vy3_,kb_]->Flatten[{kb}];
GGGEindices=GGGEindices//.{1**a_->a,a_**1->a};
(*Here we remove products of Dhs which should give KroneckerDelta*)
GGGcl=GGGcl/.{
Dh[\[Mu]y_,vy1_,vy2_,vy3_,-a_,-s_,J_]**Dh[\[Mu]y_,vy1_,vy2_,vy3_,a_,b_,J_]->(\[Gamma])^(s-a)\[Delta][b,s]/(2J+1),Dh[\[Mu]y_,vy1_,vy2_,vy3_,a_,b_,J_]**Dh[\[Mu]y_,vy1_,vy2_,vy3_,-s_,-b_,J_]->(\[Gamma])^(b-s)\[Delta][a,s]/(2J+1)};
(*Here we replace products of Dhs by their sums.*)
count=1;
While[Total[count]=!=0,Module[{J},
count=Table[0,{jj,1,Lcl}];Do[
GGGcl[[lll]]=GGGcl[[lll]]/.{
Dh[\[Mu]y_,vy1_,vy2_,vy3_,a_,b_,J1_]**Dh[\[Mu]y_,vy1_,vy2_,vy3_,c_,d_,J2_]:> (SJ[{J,0,Jmax,1/2}]If[(Abs[J1-J2]<=J<=J1+J2)&&(J1+J2-J\[Element]Integers),1,0]Z[J1,J2,J,a,b,c,d,-(a+c),-(b+d)])**Dh[\[Mu]y,vy1,vy2,vy3,(a+c),(b+d),J]/; count[[lll]]++==0};
,{lll,1,Lcl}]
]];
(*Here we duplicate GGGcl making the "tilde" replacements inside the second copy*)
GGGclTilde=GGGcl/.{R[\[Mu]y_,vy1_,vy2_,vy3_,ky_]->(\[Eta] I/t) delt[ky],Dh[\[Mu]y_,vy1_,vy2_,vy3_,ay1_,by1_,J_]->X1[ay1,by1,\[Mu]y,J]};
GGGclTilde=GGGclTilde//.{a_**b_->a b};
(*Here we replace products of Dh and R by some undefined functions.*)
GGGcl=GGGcl/.{
R[\[Mu]y_,vy1_,vy2_,vy3_,kz_]->RHold};
tt3=SessionTime[];
GGGcl=Table[GGGcl[[lll,m,i1,i2,i3]]/.{Dh[m,i1-1,i2-1,i3-1,ay1_,by1_,J_]->Flatten[
If[GGGNE[[lll,m,i1,i2,i3]]>0,Product[delt[Flatten[GGGEindices[[lll,m,i1,i2,i3]]][[iInd]]],{iInd,1,GGGNE[[lll,m,i1,i2,i3]]}],1](I \[Eta]/t/RHold)^GGGNE[[lll,m,i1,i2,i3]]{X1[ay1,by1,m,J], t GGGNE[[lll,m,i1,i2,i3]](1+GGGNE[[lll,m,i1,i2,i3]]-2 \[Eta] Coth[\[Eta]])/4/\[Eta]^2 X1[ay1,by1,m,J],t X2[ay1,by1,m,J],t(If[GGGNE[[lll,m,i1,i2,i3]]>=0,GGGvol[[lll,m,i1,i2,i3]]+GGGvol[[lll,m,1+Mod[i1+eE[m][[1]]-1,M],1+Mod[i2+eE[m][[2]]-1,M],1+Mod[i3+eE[m][[3]]-1,M]]],0]/2)Y1[ay1,by1,m,J],If[GGGNE[[lll,m,i1,i2,i3]]>0,t Table[Y2[ay1,by1,m,J,Flatten[GGGEindices[[lll,m,i1,i2,i3]]][[iInd]]]/delt[Flatten[GGGEindices[[lll,m,i1,i2,i3]]][[iInd]]],{iInd,1,GGGNE[[lll,m,i1,i2,i3]]}],0],If[GGGNE[[lll,m,i1,i2,i3]]>1,t X1[ay1,by1,m,J] Table[Table[Y3[Flatten[GGGEindices[[lll,m,i1,i2,i3]]][[iInd1]],Flatten[GGGEindices[[lll,m,i1,i2,i3]]][[iInd2]]]/delt[Flatten[GGGEindices[[lll,m,i1,i2,i3]]][[iInd1]]]/delt[Flatten[GGGEindices[[lll,m,i1,i2,i3]]][[iInd2]]],{iInd2,iInd1+1,GGGNE[[lll,m,i1,i2,i3]]}],{iInd1,1,GGGNE[[lll,m,i1,i2,i3]]}],0]}]},{lll,1,Lcl},{m,1,3},{i1,1,M},{i2,1,M},{i3,1,M}];
GGGcl=GGGcl//.{a_**b_->a b };GGGcl=GGGcl//.{RHold^k_->RHold};
GGGcl=Table[GGGcl[[lll,m,i1,i2,i3]]/.{RHold->
Flatten[If[GGGNE[[lll,m,i1,i2,i3]]>0,Product[delt[Flatten[GGGEindices[[lll,m,i1,i2,i3]]][[iInd]]],{iInd,1,GGGNE[[lll,m,i1,i2,i3]]}],1](I \[Eta]/t)^GGGNE[[lll,m,i1,i2,i3]]{1,t T[(GGGNE[[lll,m,i1,i2,i3]](1+GGGNE[[lll,m,i1,i2,i3]]-2 \[Eta] Coth[\[Eta]])/4/\[Eta]^2 )],If[GGGNE[[lll,m,i1,i2,i3]]>1, t  Table[Table[Y3[Flatten[GGGEindices[[lll,m,i1,i2,i3]]][[iInd1]],Flatten[GGGEindices[[lll,m,i1,i2,i3]]][[iInd2]]]/delt[Flatten[GGGEindices[[lll,m,i1,i2,i3]]][[iInd1]]]/delt[Flatten[GGGEindices[[lll,m,i1,i2,i3]]][[iInd2]]],{iInd2,iInd1+1,GGGNE[[lll,m,i1,i2,i3]]}],{iInd1,1,GGGNE[[lll,m,i1,i2,i3]]}],0]}]},{lll,1,Lcl},{m,1,3},{i1,1,M},{i2,1,M},{i3,1,M}];
(*Here we make the sum present after P0.*)tt4=SessionTime[];
GGGclSumRest=Table[T[1+Sum[(*GGGcl[[lll,m,i1,i2,i3]]/GGGclTilde[[lll,m,i1,i2,i3]]*)-1+ t/16/\[Eta]^2 (GGGvol[[lll,m,i1,i2,i3]]+GGGvol[[lll,m,1+Mod[i1+eE[m][[1]]-1,M],1+Mod[i2+eE[m][[2]]-1,M],1+Mod[i3+eE[m][[3]]-1,M]]])*(3-4\[Eta] Coth[\[Eta]]+GGGvol[[lll,m,i1,i2,i3]]+GGGvol[[lll,m,1+Mod[i1+eE[m][[1]]-1,M],1+Mod[i2+eE[m][[2]]-1,M],1+Mod[i3+eE[m][[3]]-1,M]]]+4GGGNE[[lll,m,i1,i2,i3]]),{m,1,3},{i1,1,M},{i2,1,M},{i3,1,M}]],{lll,1,Lcl}];
(*We make the product "P0" and multiply it with GGGclSum and its prefactor*)
FullProd=Table[0,{jj,1,Lcl}];
Do[FullProd[[lll]]=Product[GGGclTilde[[lll,m1,i11,i21,i31]],{m1,1,3},{i11,1,M},{i21,1,M},{i31,1,M}],{lll,1,Lcl}];
SecondPartofGGGclProd=Table[Table[PclHumC[[lll,1]]Qfactor[[lll]] Product[GGGclTilde[[lll,m1,i11,i21,i31]],{m1,1,3},{i11,1,M},{i21,1,M},{i31,1,M}]GGGcl[[lll,m,i1,i2,i3]]/GGGclTilde[[lll,m,i1,i2,i3]],{m,1,3},{i1,1,M},{i2,1,M},{i3,1,M}],{lll,1,Lcl}];
GGGclProd=Join[Table[PclHumC[[lll,1]]Qfactor[[lll]]Product[GGGclTilde[[lll,m,i1,i2,i3]],{m,1,3},{i1,1,M},{i2,1,M},{i3,1,M}]GGGclSumRest[[lll]],{lll,1,Lcl}],Flatten[SecondPartofGGGclProd]];
(*We transform the result to a collection of monomials.*)tt5=SessionTime[];
GGGclProd=Times@@@Tally[GGGclProd];
tt6=SessionTime[];
Lcl=Length[GGGclProd];
(*Here we extract the dummy indices from "S", and store them in GGGclInd. The "fake" enters this list if there are not dummy indices. The crazy object Prev[54] is here also from technical reasons*)
GGGclInd=Table[If[GGGclProd[[lll]]=!=0,PartToDelInd=Prev[54]GGGclProd[[lll]]/(GGGclProd[[lll]]/.{S[x_]->1,S[x_,y_,z_]->1,S[x_,y_,z_,t_]->1}),PartToDelInd=Prev[54]];If[PartToDelInd=!=Prev[54],DeleteCases[Delete[0]/@Delete[0]/@{PartToDelInd},54],{fake}],{lll,1,Lcl}];
(*We extract special "J" indices from SJ.*)tt6a=SessionTime[];
GGGclIndJ=Table[If[GGGclProd[[lll]]=!=0,PartToDelInd=Prev[54]GGGclProd[[lll]]/(GGGclProd[[lll]]/.{SJ[x_]->1}),PartToDelInd=Prev[54]];If[PartToDelInd=!=Prev[54],DeleteCases[Delete[0]/@Delete[0]/@{PartToDelInd},54],{fake}],{lll,1,Lcl}];
(*Here we look for Kronecker deltas given as "delt" and extract information about indices which which need to be replaced by zero. At the end we also remove all S and delt from GGGclProd.*)tt6b=SessionTime[];
GGGcldelt=Table[If[GGGclProd[[lll]]=!=0,PartToDelDelt=Prev[54]GGGclProd[[lll]]/(GGGclProd[[lll]]/.{delt[x_]->1}),PartToDelDelt=Prev[54]];If[PartToDelDelt=!=Prev[54],DeleteCases[Delete[0]/@Delete[0]/@{PartToDelDelt},54],fake],{lll,1,Lcl}];
GGGcldelt=Table[Table[GGGcldelt[[lll,k]]->0,{k,1,Length[GGGcldelt[[lll]]]}],{lll,1,Lcl}];tt6c=SessionTime[];
GGGclProd=GGGclProd/.{SJ[x_]->1,S[x_]->1,S[x_,y_,z_]->1,S[x_,y_,z_,t_]->1,delt[x_]->1};
(*Now we remove from GGGclInd all indices affected by deltas. We also set in GGGclProd all these indices to 0.*)
GGGclInd=Table[DeleteCases[DeleteCases[GGGclInd[[lll]]/.GGGcldelt[[lll]],0],fake],{lll,1,Lcl}];
GGGclProd=Table[GGGclProd[[lll]]/.GGGcldelt[[lll]],{lll,1,Lcl}];tt6d=SessionTime[];
(*Now we supplement the indices from RVar in GGGclInd with corresponding summation ranges.*)
GGGclInd=GGGclInd/.RepInd;
(*Here we also make use of the fact that ff[k_,0,0]=0 for all considered k*)
GGGclProd=GGGclProd/.{ff[x_,0,0]->0,ff[0,x_,0]->0,ff[0,0,x_]->0};
(*Here we do (almost) the same big procedure for the quantum part, so we already replace R by deltas (not Kronecker but - given by an undefined symbol delt) and replace Q by a proper numerical factor. "Vol" is a dummy quantity further used to collect powers of Q.*)tt7=SessionTime[];
GGGqu=SimplifyQ[Table[PquHumQ[[lll,1]]/.{Dh[\[Mu]y_,vy1_,vy2_,vy3_,ay_,by_,J_]->If[\[Mu]y==m&&vy1==i1&&vy2==i2&&vy3==i3,Dh[\[Mu]y,vy1,vy2,vy3,ay,by,J],1],R[\[Mu]y_,vy1_,vy2_,vy3_,ky_]->If[\[Mu]y==m&&vy1==i1&&vy2==i2&&vy3==i3,(\[Eta] I/t) delt[ky],1],Q[vy1_,vy2_,vy3_,Nx_]->If[vy1==i1&&vy2==i2&&vy3==i3,(-gv \[Eta]/t*(Const))^(Nx),1]},{lll,1,Lqu},{m,1,3},{i1,0,M-1},{i2,0,M-1},{i3,0,M-1}]];
GGGqu=GGGqu//.{1**a_->a,a_**1->a};
(*Here we remove products of Dhs which should give KroneckerDelta*)
GGGqu=GGGqu/.{
Dh[\[Mu]y_,vy1_,vy2_,vy3_,-a_,-s_,J_]**Dh[\[Mu]y_,vy1_,vy2_,vy3_,a_,b_,J_]->(\[Gamma])^(s-a)\[Delta][b,s]/(2J+1),Dh[\[Mu]y_,vy1_,vy2_,vy3_,a_,b_,J_]**Dh[\[Mu]y_,vy1_,vy2_,vy3_,-s_,-b_,J_]->(\[Gamma])^(b-s)\[Delta][a,s]/(2J+1)};
(*Here we replace products of Dhs by their sums.*)
count=1;
While[Total[count]=!=0,Module[{J},
count=Table[0,{jj,1,Length[GGGqu]}];Do[
GGGqu[[lll]]=GGGqu[[lll]]/.{
Dh[\[Mu]y_,vy1_,vy2_,vy3_,a_,b_,J1_]**Dh[\[Mu]y_,vy1_,vy2_,vy3_,c_,d_,J2_]:> (SJ[{J,0,Jmax,1/2}]If[(Abs[J1-J2]<=J<=J1+J2)&&(J1+J2-J\[Element]Integers),1,0]Z[J1,J2,J,a,b,c,d,-(a+c),-(b+d)])**Dh[\[Mu]y,vy1,vy2,vy3,(a+c),(b+d),J]/; count[[lll]]++==0};
,{lll,1,Length[GGGqu]}]
]];
(*Here we replace single Dh by an undefined symbol X1. We also remove extra "**". Finally we collect powers of Q, by replacing "Vol".*)
GGGqu=GGGqu/.{Dh[\[Mu]y_,vy1_,vy2_,vy3_,ay1_,by1_,J_]->X1[ay1,by1,\[Mu]y,J]};GGGqu=GGGqu//.{a_**b_->a b};
(*GGGqu=GGGqu/.{Vol^Nx_\[Rule]2^(Nx)};*)
(*We make the product "P0" (see the Algorithm) and multiply it with its prefactor*)
GGGquProd=Table[PquHumC[[lll,1]]Product[GGGqu[[lll,m,i1,i2,i3]],{m,1,3},{i1,1,M},{i2,1,M},{i3,1,M}],{lll,1,Lqu}];
GGGquProd=GGGquProd//.a_**1->a;
(*Here we extract the dummy indices from "S", and store them in GGGquInd. The "fake" enters this list if there are no dummy indices. The crazy object Prev[54] is here also from technical reasons*)
GGGquInd=Table[If[GGGquProd[[lll]]=!=0,PartToDelInd=Prev[54]GGGquProd[[lll]]/(GGGquProd[[lll]]/.{S[x_]->1,S[x_,y_,z_]->1,S[x_,y_,z_,t_]->1}),PartToDelInd=Prev[54]];If[PartToDelInd=!=Prev[54],DeleteCases[Delete[0]/@Delete[0]/@{PartToDelInd},54],{fake}],{lll,1,Lqu}];
(*We extract special "J" indices from SJ.*)
GGGquIndJ=Table[If[GGGquProd[[lll]]=!=0,PartToDelInd=Prev[54]GGGquProd[[lll]]/(GGGquProd[[lll]]/.{SJ[x_]->1}),PartToDelInd=Prev[54]];If[PartToDelInd=!=Prev[54],DeleteCases[Delete[0]/@Delete[0]/@{PartToDelInd},54],{fake}],{lll,1,Lqu}];
(*Here we look for Kronecker deltas given as "delt" and extract information about indices which which need to be replaced by zero. At the end we also remove all S and delt from GGGquProd.*)
GGGqudelt=Table[If[GGGquProd[[lll]]=!=0,PartToDelDelt=Prev[54]GGGquProd[[lll]]/(GGGquProd[[lll]]/.{delt[x_]->1}),PartToDelDelt=Prev[54]];If[PartToDelDelt=!=Prev[54],DeleteCases[Delete[0]/@Delete[0]/@{PartToDelDelt},54],fake],{lll,1,Lqu}];
GGGqudelt=Table[Table[GGGqudelt[[lll,k]]->0,{k,1,Length[GGGqudelt[[lll]]]}],{lll,1,Lqu}];
GGGquProd=GGGquProd/.{SJ[x_]->1,S[x_]->1,S[x_,y_,z_]->1,S[x_,y_,z_,t_]->1,delt[x_]->1};
(*Now we remove from GGGquInd all indices affected by deltas. We also set in GGGquProd all these indices to 0.*)
GGGquInd=Table[DeleteCases[DeleteCases[GGGquInd[[lll]]/.GGGqudelt[[lll]],0],fake],{lll,1,Lqu}];
GGGquProd=Table[GGGquProd[[lll]]/.GGGqudelt[[lll]],{lll,1,Lqu}];
(*Now we supplement the indices in GGGquInd with corresponding summation ranges.*)
GGGquInd=GGGquInd/.RepInd;
(*Here we also make use of the fact that ff[k_,0,0]=0 for all considered k*)
GGGquProd=GGGquProd/.{ff[x_,0,0]->0,ff[0,x_,0]->0,ff[0,0,x_]->0};
(*Here we bring the values for final replacements*)
Do[Do[\[Tau]n[\[Mu],k,a,b,J]=\[Tau]nAux[\[Mu],k,a,b,J],{k,-1,1},{a,-J,J},{b,-J,J},{\[Mu],1,3}],{J,Jset}];Do[ff[k1,k2,k3]=ffAux[k1,k2,k3],{k1,-1,1},{k2,-1,1},{k3,-1,1}];
Do[EpsilonN[a,b,c,m1,m2,m3]= EpsilonNAux[a,b,c,m1,m2,m3],{a,-1,1},{b,-1,1},{c,-1,1},{m1,1,3},{m2,1,3},{m3,1,3}];
(**)
Do[Do[X1[ay1,by1,\[Mu]y,J]=X1Aux[ay1,by1,\[Mu]y,J],{ay1,-J,J},{by1,-J,J},{\[Mu]y,1,3}],{J,Jset}];
Do[Do[X2[ay1,by1,\[Mu]y,J]=X2Aux[ay1,by1,\[Mu]y,J],{ay1,-J,J},{by1,-J,J},{\[Mu]y,1,3}],{J,Jset}];
Do[Do[Y1[ay1,by1,m,J]=Y1Aux[ay1,by1,m,J],{ay1,-J,J},{by1,-J,J},{m,1,3}],{J,Jset}];
Do[Do[Y2[ay1,by1,m,J,kz]=
Y2Aux[ay1,by1,m,J,kz],{ay1,-J,J},{by1,-J,J},{kz,-1,1},{m,1,3}],{J,Jset}];
Do[Y3[ky,kz]=Y3Aux[ky,kz],{ky,-1,1},{kz,-1,1}];
Z[J1_,J2_,J_,a_,b_,c_,d_,m_,n_]:=If[(J1+J2<=Jmax)&&Abs[J1-J2]<=J<=J1+J2,1,0]ZAuxP[1,J1,J2,J,a,c,m]ZAuxP[2,J1,J2,J,b,d,n];
Do[loopcoefficent[a5,a1,b3,b1]=loopcoefficentAux[a5,a1,b3,b1],{a5,-1/2,1/2},{a1,-1/2,1/2},{b3,-1/2,1/2},{b1,-1/2,1/2}];
(*Here we perform the final computation. We include summation ranges and perform the sums.*)
tt8=SessionTime[];
(*we realize that a lot of duplicates appear in GGGclProd. Hence, we merge them (and the equivalent terms in GGGclInd)*)
inter=Gather[Transpose[{GGGclProd,Transpose[{GGGclInd,GGGclIndJ}]}],#1[[2]]===#2[[2]]&];Lint=Length[inter];inter2=Table[0,{ll,1,Lint}];Combo={};
Do[inter2[[lll]]=Sum[inter[[lll]][[kkk]][[1]],{kkk,1,Length[inter[[lll]]]}],{lll,1,Lint}];
Do[If[Head[inter2[[lll]]]===Plus,
If[Not[inter2[[lll]]===0],Do[AppendTo[Combo,{inter2[[lll]][[kk]],inter[[lll]][[1]][[2]]}],{kk,1,Length[inter2[[lll]]]}]],AppendTo[Combo,{inter2[[lll]],inter[[lll]][[1]][[2]]}]],{lll,1,Length[inter2]}];
Lcl=Length[Combo];
GGGclInd=Table[Combo[[lll,2,1]],{lll,1,Lcl}];
GGGclIndJ=Table[Combo[[lll,2,2]],{lll,1,Lcl}];
GGGclProd=Table[Combo[[lll,1]],{lll,1,Lcl}];

For[lll=1,lll<=Lcl,lll++,{
For[dum=1,dum<=Length[IndicesIni],dum++,{AppendTo[GGGclInd[[lll]],IndicesIni[[dum]]]}]}];
vorfactor=Table[0,{jj,1,Lcl}];
Do[
vorfactor[[lll]]=GGGclProd[[lll]];
If[GGGclIndJ[[lll]][[1]]===fake,Do[vorfactor[[lll]]=Select[Level[vorfactor[[lll]],1],FreeQ[#,GGGclInd[[lll]][[a]][[1]]]==True&]/.{List->Times},{a,1,Length[GGGclInd[[lll]]]}],Do[Do[vorfactor[[lll]]=Select[Level[vorfactor[[lll]],1],FreeQ[#,GGGclInd[[lll]][[a]][[1]]]&&FreeQ[#,GGGclIndJ[[lll,b,1]]]==True&]/.{List->Times},{a,1,Length[GGGclInd[[lll]]]}],{b,1,Length[GGGclIndJ[[lll]]]}]];
If[Not[vorfactor[[lll]]===1],GGGclProd[[lll]]=Together[GGGclProd[[lll]]/vorfactor[[lll]]]];
,{lll,1,Lcl}];
inter=Gather[Transpose[{vorfactor,Transpose[{GGGclProd,Transpose[{GGGclInd,GGGclIndJ}]}]}],#1[[2]]===#2[[2]]&];Lint=Length[inter];inter2=Table[0,{ll,1,Lint}];
vorfactor=Table[T[Sum[inter[[jj,kk,1]],{kk,1,Length[inter[[jj]]]}]],{jj,1,Lint}];
Lcl=Lint;
GGGclInd=Table[inter[[lll,1,2,2,1]],{lll,1,Lcl}];
GGGclIndJ=Table[inter[[lll,1,2,2,2]],{lll,1,Lcl}];
GGGclProd=Table[inter[[lll,1,2,1]]//.{X1[d_,f_,mu_,J3_] ZAuxP[1,J1_,J2_,J3_,a_,c_,__] ZAuxP[2,J1_,J2_,J3_,g_,h_,__]->X1[a,g,mu,J1] X1[c,h,mu,J2]/(If[J1>J2,2 J2+1,2 J1+1])},{lll,1,Lcl}];
tt9=SessionTime[];
Rezcl=Table[0,{j,1,Lcl}];
Rezqu=Table[0,{j,1,Lqu}];

Clear[\[Gamma]];For[lll=1,lll<=Lcl,lll++,{

If[GGGclProd[[lll]]===0,Rezcl[[lll]]=0,
GGGclProdPure=GGGclProd[[lll]];
(*GGGclProd will have some prefactors, especially after the sums from volume have been done. Before doing the remaining sums to speed the summation up, we remove the prefactor, i.e. everything not depending on a summation index.*)
RepIndices={};RepIndTemp={};
Do[If[Not[FreeQ[vorfactor[[lll]],VolVar[[jj]]]],vorfactor[[lll]]=Together[Sum[(vorfactor[[lll]]//.{VolVar[[jj]]->n,TT[x_]->x, T[x_]->x}),{n,0,2 (2 MVolAppr+1)}]]],{jj,1,VolLength}];
(*We  perform the summations. *)
GGGclIndTemp=Complement[GGGclInd[[lll]],IndicesIni];
If[Length[GGGclIndTemp]>0,
Do[RepIndices=Append[RepIndices,Table[{GGGclIndTemp[[jj,1]]->ss},{ss,GGGclIndTemp[[jj,2]],GGGclIndTemp[[jj,3]]}]],{jj,1,Length[GGGclIndTemp]}]];
If[GGGclIndJ[[lll]][[1]]===fake,GGGclProdPure=GGGclProdPure,
If[Length[GGGclIndJ[[lll]]]>= 5,
GGGclProdPure=Sum[GGGclProdPure,Sequence@@Take[GGGclIndJ[[lll]],Floor[Length[GGGclIndJ[[lll]]]/2]]//Evaluate];
GGGclProdPure=Factor[GGGclProdPure];
GGGclProdPure=Sum[GGGclProdPure,Sequence@@Take[GGGclIndJ[[lll]],{Floor[Length[GGGclIndJ[[lll]]]/2]+1,-1}]//Evaluate],GGGclProdPure=Sum[GGGclProdPure,Sequence@@GGGclIndJ[[lll]]//Evaluate]]
];
GGGclProdPure=Factor[GGGclProdPure];
If[Length[RepIndices]>0,Do[GGGclProdPure=Total[GGGclProdPure/.RepIndices[[jj]]],{jj,1,Length[RepIndices]}]];
GGGclProdPure=Factor[GGGclProdPure];
RepIndices={};
Do[RepIndices=Append[RepIndices,Table[{IndicesIni[[jj,1]]->ss},{ss,IndicesIni[[jj,2]],IndicesIni[[jj,3]]}]],{jj,1,Length[IndicesIni]}];Do[GGGclProdPure=Total[GGGclProdPure/.RepIndices[[jj]]],{jj,1,Length[RepIndices]}];
(*We restore the prefactors*)
Rezcl[[lll]]=vorfactor[[lll]]*GGGclProdPure//.{TT[x_]->x, T[x_]-> x};
GGGclProd[[lll]]=0]
;}];\[Gamma]=-1;gv=(I 6)^(1/3)2 I;
Resultc[[iii]]=Series[PowerExpand[(Sum[Rezcl[[k]],{k,1,Lcl}]//.a_**1->a )/.{q0->q1/t^3}/.{q1->48 Const^3 \[Eta]^3*(1+3 t/(2 \[Eta]^2) (1-\[Eta] Coth[\[Eta]]))}],{t,0,1}];tt10=SessionTime[];
Clear[\[Gamma]];For[lll=1,lll<=Lqu,lll++,{
For[dum=1,dum<=Length[IndicesIni],dum++,{AppendTo[GGGquInd[[lll]],IndicesIni[[dum]]]}];
If[GGGquProd[[lll]]===0,Rezqu[[lll]]=0,
vorfactor=GGGquProd[[lll]];
If[GGGquIndJ[[lll]][[1]]===fake,Do[vorfactor=Select[Level[vorfactor,1],FreeQ[#,GGGquInd[[lll]][[a]][[1]]]==True&]/.{List->Times},{a,1,Length[GGGquInd[[lll]]]}],Do[Do[vorfactor=Select[Level[vorfactor,1],FreeQ[#,GGGquInd[[lll]][[a]][[1]]]&&FreeQ[#,GGGquIndJ[[lll,b,1]]]==True&]/.{List->Times},{a,1,Length[GGGquInd[[lll]]]}],{b,1,Length[GGGquIndJ[[lll]]]}]];
If[vorfactor===1,GGGquProdPure=GGGquProd[[lll]],GGGquProdPure=Together[GGGquProd[[lll]]/vorfactor]];
Do[If[Not[FreeQ[vorfactor,VolVar[[jj]]]],vorfactor=Together[Sum[(vorfactor//.{VolVar[[jj]]->n,TT[x_]->x,T[x_]->x}),{n,0,2 (2 MVolAppr+1)}]]],{jj,1,VolLength}];
RepIndices={};RepIndTemp={};
Do[RepIndices=Append[RepIndices,Table[{GGGquInd[[lll]][[jj]][[1]]->ss},{ss,GGGquInd[[lll]][[jj]][[2]],GGGquInd[[lll]][[jj]][[3]]}]],{jj,1,Length[GGGquInd[[lll]]]}];
If[GGGquIndJ[[lll]][[1]]===fake,GGGquProdPure=GGGquProdPure,
If[Length[GGGquIndJ[[lll]]]>= 5,
GGGquProdPure=Sum[GGGquProdPure,Sequence@@Take[GGGquIndJ[[lll]],Floor[Length[GGGquIndJ[[lll]]]/2]]//Evaluate];
GGGquProdPure=Factor[GGGquProdPure];
GGGquProdPure=Sum[GGGquProdPure,Sequence@@Take[GGGquIndJ[[lll]],{Floor[Length[GGGquIndJ[[lll]]]/2]+1,-1}]//Evaluate],GGGquProdPure=Sum[GGGquProdPure,Sequence@@GGGquIndJ[[lll]]//Evaluate]]
];
GGGquProdPure=Factor[GGGquProdPure];
Do[GGGquProdPure=Total[GGGquProdPure/.RepIndices[[jj]]],{jj,1,Length[RepIndices]}];
Rezqu[[lll]]=vorfactor*GGGquProdPure//.{TT[x_]->x,T[x_]-> x};
GGGquProd[[lll]]=0]
;}];\[Gamma]=-1;gv=(I 6)^(1/3)2 I;tt11=SessionTime[];
Resultq[[iii]]=Normal[Series[Sum[Rezqu[[k]],{k,1,Lqu}]//.a_**1->a,{t,0,1}]];
Resultq[[iii]]=Series[PowerExpand[Resultq[[iii]]/.{q0->q1/t^3}/.{q1->48 Const^3 \[Eta]^3*(1+3 t/(2 \[Eta]^2) (1-\[Eta] Coth[\[Eta]]))}],{t,0,1}];
LoopCounting=LoopCounting+1,
{iii,1,Lop}]]

(*We restore some intermediate parameters, to enable the correct expansion wrt t.*)
q0:=48Const^3 \[Eta]^3/t^3*(1+3t/(2\[Eta]^2)(1-\[Eta] Coth[\[Eta]]));
z=\[Xi]-I \[Eta];Print["Evaluating Expectation Values: Time ",Round[SessionTime[]-timestamp2,0.01]];


(*The result is expaneded to subleading order in t and simplified*)
timestamp2=SessionTime[];
Print["Expand linear in t..."];
Result1=Series[PowerExpand[(Sum[Resultc[[iii]]+Resultq[[iii]],{iii,1,Lop}])],{t,0,1}];
Print["Expand: Time ",Round[SessionTime[]-timestamp2,0.01]];
timestamp2=SessionTime[];
Print["Simplify Result..."];Result=Simplify[Result1];Print["Simplify: Time ",Round[SessionTime[]-timestamp2,0.01]]


(*Result is exportet as a txt file with title specified in "User Input"*)
Export["ExpValue_Result_"<>ToString[Title]<>".txt",Normal[Result]];


Print["Total Time: ",Round[SessionTime[]-timestamp1,0.01]];


(*The result involves some parameters that have not yet been specified. For the above defined examples, these are:*)
tinv=1/t;
pV= (\[Beta]  t l^2)^(3/2)/(2^(7/2) Sqrt[3]);
pEuc= (1/( I  \[Kappa] \[Beta] l^2 )) (* 1/t removed because it is in General Operator definitions*);
\[Eta]= 2 \[Epsilon]^2 p /(l^2 \[Beta]);
\[Xi]=- \[Epsilon] c ;
Const=\[HBar] \[Kappa] \[Beta]/2;


CloseKernels[];
Quit
